pipeline {
  agent any

  triggers { pollSCM('H/2 * * * *') }

  environment {
    NS            = 'default'
    APP           = 'mydjangoapp'
    DEPLOY        = 'django-deployment'
    CTR           = 'django-container'
    DOCKER_CTX    = 'videostore'
    MANIFEST_DIR  = 'videostore'

    MK_ROOT       = '/var/jenkins_home/minikube/videostore'
    MINIKUBE_HOME = "${MK_ROOT}/.minikube"
    KUBECONFIG    = "${MK_ROOT}/.kube/config"

    MK_DOCKER_NET = 'minikube-net'
    MK_SUBNET     = '10.123.0.0/16'
    MINIKUBE_IN_A_CONTAINER = 'true'
  }

  options { timestamps() }

  stages {
    stage('Checkout') {
      steps {
        cleanWs()
        git branch: 'main', url: 'https://github.com/eliasghnm/repo1'
      }
    }

    stage('Install CLIs (once)') {
      steps {
        sh '''
          set -euo pipefail
          if ! command -v minikube >/dev/null 2>&1; then
            curl -fsSL https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64 -o /usr/local/bin/minikube
            chmod +x /usr/local/bin/minikube
          fi
          if ! command -v kubectl >/dev/null 2>&1; then
            KVER="$(curl -fsSL https://dl.k8s.io/release/stable.txt)"
            curl -fsSL "https://dl.k8s.io/release/${KVER}/bin/linux/amd64/kubectl" -o /usr/local/bin/kubectl
            chmod +x /usr/local/bin/kubectl
          fi
          apt-get update -y
          apt-get install -y --no-install-recommends iproute2 socat curl ca-certificates
          mkdir -p "${MINIKUBE_HOME}" "$(dirname "${KUBECONFIG}")"
        '''
      }
    }

    stage('Prepare dedicated Docker network for Minikube') {
      steps {
        sh '''
          set -euo pipefail

          # Ensure network exists
          if ! docker network inspect "${MK_DOCKER_NET}" >/dev/null 2>&1; then
            docker network create --driver=bridge --subnet="${MK_SUBNET}" "${MK_DOCKER_NET}"
          fi

          # Jenkins container id (hostname == container id)
          JENKINS_ID="$(hostname)"

          # Attach jenkins container to network if not already attached
          if docker inspect "${JENKINS_ID}" >/dev/null 2>&1; then
            if ! docker inspect -f '{{json .NetworkSettings.Networks}}' "${JENKINS_ID}" | grep -q "\"${MK_DOCKER_NET}\":" ; then
              echo "Attaching Jenkins container ${JENKINS_ID} to ${MK_DOCKER_NET} (alias: jenkins)"
              docker network connect --alias jenkins "${MK_DOCKER_NET}" "${JENKINS_ID}" || true
            fi
          else
            echo "WARN: Unable to inspect Jenkins container (${JENKINS_ID}); skipping network attach."
          fi
        '''
      }
    }

    stage('Start or Re-use Minikube (race-free bridge, POSIX)') {
      steps {
        sh '''
          set -euo pipefail
          export NO_PROXY="127.0.0.1,localhost,.local,.svc,cluster.local,10.96.0.0/12,10.244.0.0/16,10.123.0.0/16"
          export no_proxy="${NO_PROXY}"
          unset HTTP_PROXY HTTPS_PROXY http_proxy https_proxy || true

          # Kill any leftover bridge listeners to avoid duplicates
          pkill -f minikube_port_bridge.sh >/dev/null 2>&1 || true
          pkill -f "socat TCP-LISTEN" >/dev/null 2>&1 || true

          # --- background bridge loop (POSIX) ---
          cat > /tmp/minikube_port_bridge.sh <<'EOSH'
#!/usr/bin/env sh
set -eu
parse_host_port() { awk -F':' '{print $NF}'; }
while :; do
  PORT_MAPS="$(docker port minikube 2>/dev/null || true)"
  if [ -n "${PORT_MAPS}" ]; then
    echo "${PORT_MAPS}" | while IFS= read -r line; do
      [ -z "${line}" ] && continue
      HOST_PORT="$(echo "${line}" | parse_host_port)"
      case "${HOST_PORT}" in ''|*[!0-9]*) continue;; esac
      if ! ss -ltn 2>/dev/null | awk '{print $4}' | grep -q ":${HOST_PORT}\$"; then
        nohup socat TCP-LISTEN:${HOST_PORT},fork,reuseaddr TCP:host.docker.internal:${HOST_PORT} >/dev/null 2>&1 &
        echo "[BRIDGE] Forwarding container localhost:${HOST_PORT} -> host.docker.internal:${HOST_PORT}"
      fi
    done
  fi
  sleep 1
done
EOSH
          chmod +x /tmp/minikube_port_bridge.sh
          nohup /tmp/minikube_port_bridge.sh >/tmp/port-bridge.log 2>&1 &

          # --- self-heal: if cluster exists but SSH auth is broken, delete for clean recreate ---
          if minikube status -p minikube >/dev/null 2>&1; then
            HOSTPORT="$(docker inspect -f '{{(index (index .NetworkSettings.Ports "22/tcp") 0).HostPort}}' minikube 2>/dev/null || true)"
            KEY="$(minikube ssh-key -p minikube 2>/dev/null || true)"
            if [ -n "${HOSTPORT:-}" ] && [ -n "${KEY:-}" ]; then
              if ! ssh -o StrictHostKeyChecking=no -o BatchMode=yes -i "${KEY}" docker@127.0.0.1 -p "${HOSTPORT}" true 2>/dev/null; then
                echo "Minikube SSH key mismatch; deleting cluster..."
                minikube delete -p minikube --all --purge || true
              fi
            fi
          fi

          # --- reuse or start cluster (safe under -euo pipefail) ---
          if minikube status -p minikube >/dev/null 2>&1 && \
             minikube status -p minikube | grep -q Running; then
            echo "Reusing existing, running Minikube cluster."
            minikube -p minikube update-context
          else
            echo "Starting Minikube…"
            if ! minikube start -p minikube \
              --driver=docker \
              --container-runtime=containerd \
              --kubernetes-version=v1.30.0 \
              --cpus=2 --memory=4096 \
              --network="${MK_DOCKER_NET}" \
              --wait=all \
              --force \
              -v=3 --alsologtostderr; then
              echo "Start failed; deleting profile then retrying…"
              minikube delete -p minikube || true
              minikube start -p minikube \
                --driver=docker \
                --container-runtime=containerd \
                --kubernetes-version=v1.30.0 \
                --cpus=2 --memory=4096 \
                --network="${MK_DOCKER_NET}" \
                --wait=all \
                --force \
                -v=3 --alsologtostderr
            fi
          fi

          # --- explicit apiserver bridge + wait ---
          API_HOST_PORT="$(docker port minikube 8443/tcp | awk -F':' '{print $NF}' | tail -n1 || true)"
          case "${API_HOST_PORT}" in
            ''|*[!0-9]*)
              echo "[APISERVER] Could not determine host port from 'docker port minikube 8443/tcp'"
              docker port minikube || true
              ;;
            *)
              echo "[APISERVER] Host port is ${API_HOST_PORT}"
              if ! ss -ltn 2>/dev/null | awk '{print $4}' | grep -q ":${API_HOST_PORT}\$"; then
                nohup socat TCP-LISTEN:${API_HOST_PORT},fork,reuseaddr TCP:host.docker.internal:${API_HOST_PORT} >/dev/null 2>&1 &
                echo "[APISERVER] Dedicated forward started on :${API_HOST_PORT}"
              fi
              printf "[APISERVER] Waiting for localhost:%s " "${API_HOST_PORT}"
              i=0
              while ! socat - TCP:127.0.0.1:${API_HOST_PORT},connect-timeout=1 </dev/null >/dev/null 2>&1; do
                i=$((i+1)); [ "${i}" -ge 90 ] && { echo "TIMEOUT"; tail -n 100 /tmp/port-bridge.log || true; exit 1; }
                printf "."; sleep 1
              done
              echo "OK"
              ;;
          esac

          echo "Verifying cluster connectivity..."
          kubectl config current-context
          kubectl get nodes -o wide
        '''
      }
    }

    stage('Compute Tag') {
      steps {
        script {
          env.TAG   = sh(returnStdout: true, script: 'git rev-parse --short HEAD').trim()
          env.IMAGE = "${env.APP}:${env.TAG}"
          echo "IMAGE=${env.IMAGE}"
        }
      }
    }

    stage('Build Docker Image (local)') {
      steps {
        dir(env.DOCKER_CTX) {
          sh "docker build -t ${IMAGE} ."
        }
      }
    }

    stage('Load Image into Minikube') {
      steps { sh "minikube -p minikube image load ${IMAGE}" }
    }

    stage('Apply Manifests & Rollout') {
      steps {
        sh """
          set -euo pipefail
          kubectl -n ${NS} apply -f ${MANIFEST_DIR}/deployment.yaml
          kubectl -n ${NS} apply -f ${MANIFEST_DIR}/service.yaml
          kubectl -n ${NS} set image deploy/${DEPLOY} ${CTR}=${IMAGE}
          kubectl -n ${NS} rollout status deploy/${DEPLOY} --timeout=180s
          kubectl -n ${NS} get deploy,pods,svc -o wide
        """
      }
    }

    stage('Pods Snapshot & Debug') {
      steps {
        sh '''
          set -euo pipefail
          echo "== Context =="; kubectl config current-context || true
          echo "== All namespaces =="; kubectl get pods -A -o wide || true
          echo "== App namespace (${NS}) =="; kubectl -n ${NS} get deploy,po,svc,ep -o wide || true

          not_ready="$(kubectl -n ${NS} get pods --no-headers | awk '$2 != "1/1" || $3 != "Running" {print $1}')"
          if [ -n "${not_ready}" ]; then
            for p in ${not_ready}; do
              echo "---- describe $p ----"
              kubectl -n ${NS} describe pod "$p" || true
              echo "---- logs (all containers) $p ----"
              kubectl -n ${NS} logs --all-containers=true --prefix "$p" || true
            done
          fi
        '''
      }
    }

    stage('Make Interactive Access Easy (wrappers + helpers)') {
      steps {
        sh '''
          set -euo pipefail
          mkdir -p "${MINIKUBE_HOME}" "$(dirname "${KUBECONFIG}")"

          cat > /usr/local/bin/kube-ps2 <<'EOS'
#!/usr/bin/env sh
export MK_ROOT="/var/jenkins_home/minikube/videostore"
export MINIKUBE_HOME="${MK_ROOT}/.minikube"
export KUBECONFIG="${MK_ROOT}/.kube/config"
unset HTTP_PROXY HTTPS_PROXY http_proxy https_proxy
export NO_PROXY='127.0.0.1,localhost,.local,.svc,cluster.local,10.96.0.0/12,10.244.0.0/16,10.123.0.0/16'
export no_proxy="${NO_PROXY}"
exec kubectl "$@"
EOS
          chmod +x /usr/local/bin/kube-ps2

          cat > /usr/local/bin/mk-ps2 <<'EOS'
#!/usr/bin/env sh
export MK_ROOT="/var/jenkins_home/minikube/videostore"
export MINIKUBE_HOME="${MK_ROOT}/.minikube"
export KUBECONFIG="${MK_ROOT}/.kube/config"
unset HTTP_PROXY HTTPS_PROXY http_proxy https_proxy
export NO_PROXY='127.0.0.1,localhost,.local,.svc,cluster.local,10.96.0.0/12,10.244.0.0/16,10.123.0.0/16'
export no_proxy="${NO_PROXY}"
exec minikube -p minikube "$@"
EOS
          chmod +x /usr/local/bin/mk-ps2

          cat > /usr/local/bin/start-ps2-bridge <<'EOS'
#!/usr/bin/env sh
set -eu
if ! pgrep -f minikube_port_bridge.sh >/dev/null 2>&1; then
  nohup /tmp/minikube_port_bridge.sh >/tmp/port-bridge.log 2>&1 &
fi
API_HOST_PORT="$(docker port minikube 8443/tcp | awk -F':' '{print $NF}' | tail -n1 || true)"
case "${API_HOST_PORT}" in
  ''|*[!0-9]*) echo "Could not determine API host port"; docker port minikube || true; exit 0 ;;
  *)
    if ! ss -ltn 2>/dev/null | awk '{print $4}' | grep -q ":${API_HOST_PORT}\$"; then
      nohup socat TCP-LISTEN:${API_HOST_PORT},fork,reuseaddr TCP:host.docker.internal:${API_HOST_PORT} >/dev/null 2>&1 &
    fi
    i=0; while ! socat - TCP:127.0.0.1:${API_HOST_PORT},connect-timeout=1 </dev/null >/dev/null 2>&1; do
      i=$((i+1)); [ "$i" -ge 60 ] && break; sleep 1
    done
    echo "Bridge ready on :${API_HOST_PORT}"
    ;;
esac
EOS
          chmod +x /usr/local/bin/start-ps2-bridge

          cat > /usr/local/bin/stop-ps2-bridge <<'EOS'
#!/usr/bin/env sh
pkill -f minikube_port_bridge.sh >/dev/null 2>&1 || true
pkill -f "socat TCP-LISTEN" >/dev/null 2>&1 || true
echo "Bridge stopped"
EOS
          chmod +x /usr/local/bin/stop-ps2-bridge

          echo "Installed: kube-ps2, mk-ps2, start-ps2-bridge, stop-ps2-bridge"
        '''
      }
    }

    stage('Expose Django URL (print for Windows)') {
      steps {
        sh '''
          set -euo pipefail
          start-ps2-bridge
          echo "Discovering a Windows-friendly URL for django-service..."
          # Keep simple in first iteration; your advanced expose script can be added later
          kubectl -n ${NS} get svc django-service -o wide || true
        '''
      }
    }

    stage('Archive K8s Snapshot') {
      steps {
        sh '''
          set -euo pipefail
          mkdir -p k8s-dump
          kubectl config view --minify > k8s-dump/kubeconfig-view.txt || true
          kubectl -n ${NS} get deploy,po,rs,svc,ep -o wide > k8s-dump/resources.txt || true
          kubectl -n ${NS} get events --sort-by=.lastTimestamp > k8s-dump/events.txt || true
        '''
        archiveArtifacts artifacts: 'k8s-dump/**', allowEmptyArchive: true
      }
    }
  }

  post {
    always {
      echo 'Pipeline finished.'
    }
    failure {
      echo 'Collecting Minikube & network logs for debugging…'
      sh 'minikube -p minikube logs --file=logs.txt || true'
      archiveArtifacts artifacts: 'logs.txt', allowEmptyArchive: true
      sh 'docker network ls || true'
      sh 'docker network inspect "${MK_DOCKER_NET}" || true'
      sh 'echo "[BRIDGE LOGS]"; tail -n 200 /tmp/port-bridge.log || true'
    }
  }
}
